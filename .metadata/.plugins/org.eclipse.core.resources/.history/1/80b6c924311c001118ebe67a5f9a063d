package test.persistence;

import static org.junit.Assert.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import java.util.LinkedList;
import java.util.List;
import org.gemsjax.server.persistence.HibernateUtil;
import org.gemsjax.server.persistence.dao.CollaborateableDAO;
import org.gemsjax.server.persistence.dao.ExperimentDAO;
import org.gemsjax.server.persistence.dao.NotificationDAO;
import org.gemsjax.server.persistence.dao.RequestDAO;
import org.gemsjax.server.persistence.dao.UserDAO;
import org.gemsjax.server.persistence.dao.exception.AlreadyAssignedException;
import org.gemsjax.server.persistence.dao.exception.AlreadyExistException;
import org.gemsjax.server.persistence.dao.exception.ArgumentException;
import org.gemsjax.server.persistence.dao.exception.DAOException;
import org.gemsjax.server.persistence.dao.exception.EMailInUseExcpetion;
import org.gemsjax.server.persistence.dao.exception.UsernameInUseException;
import org.gemsjax.server.persistence.dao.hibernate.HibernateCollaborateableDAO;
import org.gemsjax.server.persistence.dao.hibernate.HibernateExperimentDAO;
import org.gemsjax.server.persistence.dao.hibernate.HibernateNotificationDAO;
import org.gemsjax.server.persistence.dao.hibernate.HibernateRequestDAO;
import org.gemsjax.server.persistence.dao.hibernate.HibernateUserDAO;
import org.gemsjax.server.persistence.notification.NotificationImpl;
import org.gemsjax.shared.experiment.Experiment;
import org.gemsjax.shared.metamodel.MetaModel;
import org.gemsjax.shared.notification.Notification;
import org.gemsjax.shared.request.AdministrateExperimentRequest;
import org.gemsjax.shared.request.CollaborateRequest;
import org.gemsjax.shared.request.Request;
import org.gemsjax.shared.user.RegisteredUser;
import org.junit.BeforeClass;
import org.junit.Test;

public class NotificationDAOTest {
	
	private static NotificationDAO dao;
	private static UserDAO registeredUserDAO;
	private static List<Notification> createdNotifications;
	
	
	 @BeforeClass 
	 public static void classSetup() throws UsernameInUseException, DAOException, EMailInUseExcpetion {

		 dao = new HibernateNotificationDAO();
		 registeredUserDAO = new HibernateUserDAO();
		 
		 createdNotifications=new LinkedList<Notification>();
		 	
	 }
	 
	 
//	 @AfterClass
	 public static void classSetDown() throws ArgumentException, DAOException
	 {
		 for (Notification n: createdNotifications)
		 {
			dao.deleteNotification(n);
		 }
		 
		 HibernateUtil.getSessionFactory().close();
	 }
	 
	 
	 @Test
	 public void testCollaborateRequests() throws DAOException, UsernameInUseException, EMailInUseExcpetion, AlreadyAssignedException, AlreadyExistException
	 {
		RegisteredUser receiver = registeredUserDAO.createRegisteredUser("NotificationTestReceiver", "passwordHash", "NotificationTest@receiver.com");
		 
		 int tests = 100;
		 
		 for (int i =0; i<tests; i++)
		 {
			 
			 NotificationImpl n = (NotificationImpl) dao.createNotification(receiver, Notification.COLLABORATEABLE_DELETED,"optionalMessage");
			 createdNotifications.add(n);
			
			
			 assertTrue(n.getReceiver().getId() == receiver.getId());
			 
			 List<Notification> unList = dao.getUnreadNotificationsFor(receiver);
			 assertTrue(unList.size() == i+1);
			 assertTrue(unList.contains(n));
			 
			 NotificationImpl queried = (NotificationImpl)dao.getNotification(n.getId());
			 
			 assertEquals(queried, n);
			 assertEquals(queried.getDate(), n.getDate());
			 assertTrue(queried.getOptionalMessage().equals( n.getOptionalMessage() ));
			 assertTrue(queried.getId() == n.getId());
			 assertTrue(queried.getCodeNumber() == n.getCodeNumber());
			 assertEquals(queried.getReceiver(), n.getReceiver());
			 assertFalse(queried.isRead());
			 
			 dao.setRead(n, true);
			 
			 queried = (NotificationImpl)dao.getNotification(n.getId());
			 assertTrue(queried.isRead());
			 
			 
			 List<Notification> list = dao.getNotificationsFor(receiver);
			 assertTrue(list.size() == i+1);
			 assertTrue(list.contains(n));
			 assertTrue(list.contains(queried));
			 
			
		 }
		 
		 for (Notification n : createdNotifications)
		 {
			 dao.deleteNotification(n);
		 }
		 
		 createdNotifications.clear();
		 
		 registeredUserDAO.deleteRegisteredUser(receiver);
		 
		 //collaborateableDAO.deleteCollaborateable(collaborateable);  // NOT NEEDED, because DELTETE RegisteredUser will delete all owned Collaborateables
		 
	 }
	 
	 
	 @Test
	 public void testAdministrateExperiment() throws UsernameInUseException, DAOException, EMailInUseExcpetion, ArgumentException, AlreadyAssignedException, AlreadyExistException
	 {
		 RegisteredUser sender = registeredUserDAO.createRegisteredUser("RequestTestSender", "passwordHash", "requestTest@sender.com");
		 RegisteredUser receiver = registeredUserDAO.createRegisteredUser("RequestTestReceiver", "passwordHash", "requestTest@receiver.com");
		 
		 

		 int tests = 100;
		 
		 for (int i =0; i<tests; i++)
		 {
			 
			 Experiment ex = experimentDAO.createExperiment("AdministrateRequestTestExperiment", "description", sender);
				
			 
			 AdministrateExperimentRequest r = dao.createAdministrateExperimentRequest(sender, receiver, ex);
			 createdNotifications.add(r);
			 System.out.println(r.getReceiver() + "  "+r.getSender() + r.getReceiver().getId());
			 assertTrue(r.getReceiver().getId() == receiver.getId());
			 assertTrue(r.getSender().getId() == sender.getId());
			
			 
			 List<Request> recList = dao.getAllRequestsFor(receiver);
			 assertTrue(recList.size() == i+1);
			 assertTrue(recList.contains(r));
			 
			 List<Request> sendList = dao.getAllRequestsBy(sender);
			 assertTrue(sendList.size() == i+1);
			 assertTrue(sendList.contains(r));
			 
			 
			// try to create the same Request --> Excpetion
			 try
			 {
				 dao.createAdministrateExperimentRequest(sender, receiver, ex);
				 assertTrue(false);
			 }
			 catch(AlreadyExistException e) {System.out.println("catched");}
			 
			 // try to create a request, where Receiver is already assigned to --> Exception
			 try
			 {
				 dao.createAdministrateExperimentRequest(receiver, sender, ex); // sender is the creator --> sender is an admin
				 assertTrue(false);
			 }
			 catch(AlreadyAssignedException e) {}
			 
		 }
		 
		 for (Request r : createdNotifications)
		 {
			 dao.deleteRequest(r);
		 }
		 createdNotifications.clear();
		 
		 registeredUserDAO.deleteRegisteredUser(receiver);
		 registeredUserDAO.deleteRegisteredUser(sender);
		
		 
		// experimentDAO.deleteExperiment(ex); // NOT needed, since experiment is deleted, when the owner (RegisteredUser) is deleted
		 
	 }
	 
	
}
