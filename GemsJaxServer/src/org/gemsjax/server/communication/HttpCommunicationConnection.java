package org.gemsjax.server.communication;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.LinkedHashSet;
import java.util.Set;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.http.HttpResponse;
import org.gemsjax.shared.communication.CommunicationConnection;
import org.gemsjax.shared.communication.channel.InputChannel;
import org.gemsjax.shared.communication.channel.InputMessage;
import org.gemsjax.shared.communication.message.Message;

/**
 * This is a {@link CommunicationConnection} for the classic HTTP POST and GET.
 * This kind of {@link CommunicationConnection} is normally used by a {@link HttpServlet}.
 * 
 * <br />
 * How to use:
 * <ol>
 * <li> Create a new {@link HttpCommunicationConnection} by calling the constructor and passing the {@link HttpServletRequest} and {@link HttpServletResponse}
 * generated by the {@link HttpServlet} methods like doGet() or doPost() </li>
 * <li> Register <b> {@link InputChannel}s</b> and if needed {@link ClosedListener}s and {@link EstablishedListener}s by calling {@link #registerInputChannel(InputChannel)}, {@link #addCloseListener(org.gemsjax.shared.communication.CommunicationConnection.ClosedListener)} and {@link #addEstablishedListener(org.gemsjax.shared.communication.CommunicationConnection.EstablishedListener)}.
 * <br /> Note that {@link CommunicationConnection} provides also {@link ErrorListeners}, but in this {@link HttpCommunicationConnection} errors are handled by java standard {@link Exception} system. </li>
 * <li>To start call {@link #connect()}. Connect would create the {@link HttpResponse}s {@link PrintWriter}<br />
 * 	<b>AND</b><br />
 * will push the incoming Request to the registered {@link InputChannel}s by creating a {@link InputMessage} with a parameter map.</li> 
 * </ol>
 * <b>Note</b> that by calling {@link #send(Message)} the connection will automatically be closed (by calling internally {@link #close()}),
 * since http is designed this way: get request --> generate response --> close connection.
 * @author Hannes Dorfmann
 *
 */
public class HttpCommunicationConnection implements CommunicationConnection{
	
	private HttpServletRequest request;
	private HttpServletResponse response;
	private PrintWriter writer;
	private boolean isClosed;
	private Set<InputChannel> inputChannels;
	private Set<EstablishedListener> establishedListeners;
	private Set<ClosedListener> closedListeners;
//	private Set<ErrorListener> errorListeners;
	
	public HttpCommunicationConnection(HttpServletRequest request, HttpServletResponse response)
	{
		this.request = request;
		this.response = response;
		isClosed = true;
		response.setStatus(200);
		
		inputChannels = new LinkedHashSet<InputChannel>();
		establishedListeners = new LinkedHashSet<CommunicationConnection.EstablishedListener>();
		closedListeners = new LinkedHashSet<CommunicationConnection.ClosedListener>();
//		errorListeners = new LinkedHashSet<CommunicationConnection.ErrorListener>();
		
	}
	
	
	/**
	 * Overrides the {@link CommunicationConnection#close()} method.
	 * This method closes the {@link HttpServletResponse}s {@link PrintWriter}, which is needed by {@link #send(Message)}.
	 * So after calling this method, sending a {@link Message} is not longer available
	 */
	@Override
	public void close() throws IOException
	{
		writer.close();
		isClosed = true;
		
		for (ClosedListener c : closedListeners)
			c.onClose();
	}
	
	@Override
	public boolean isClosed()
	{
		return isClosed;
	}
	
	/**
	 * This method must be called to start with a {@link CommunicationConnection}.
	 * In this case, the {@link HttpServletResponse#getWriter()} is created to enable writing a response {@link Message}
	 * via {@link #send(Message)}.<br />
	 * Also all {@link EstablishedListener} will be informed by calling {@link EstablishedListener#onEstablished()} and {@link #isConnected()}
	 * will return true (from now on, until {@link #close()} is called).
	 * In addition, connect will create a {@link InputMessage} and push that message to every registered {@link InputChannel}.
	 */
	@Override
	public void connect() throws IOException{
		writer = response.getWriter();
		isClosed = false;
		
		
		for (EstablishedListener e: establishedListeners)
			e.onEstablished();
		
		
		InputMessage im = new InputMessage(request.getParameterMap());
		
		
		for (InputChannel i : inputChannels)
			i.onMessageReceived(im);
		
	}
	
	@Override
	public  int getPort(){
		return request.getRemotePort();
	}
	
	@Override
	public  boolean isSupported()
	{
		return true;
	}
	
	@Override
	public String getRemoteAddress(){
		return request.getRemoteAddr();
	}
	
	
	public boolean isConnected(){
		return !isClosed;
	}
	
	@Override
	public void setKeepAlive(boolean  keepAlive)
	{
		throw new UnsupportedOperationException();
	}
	
	@Override
	public boolean isKeepAlive(){
		return false;
	}
	
	@Override
	public void send(Message message) throws IOException{
		
		writer.write(message.toXml());
		writer.close();
	}
	
	/**
	 * Call this, to push a {@link InputMessage} to all {@link InputChannel}s, that return ture on calling {@link InputChannel#isMatchingFilter(String)}
	 * @param message The {@link InputMessage} which should pushed
	 */
	private void fireInputChannelMessage(InputMessage message)
	{
		for (InputChannel i : inputChannels)
			if (i.isMatchingFilter(message.getText()))
				i.onMessageReceived(message);
	}
	
	
	@Override
	public void registerInputChannel(InputChannel c)
	{
		inputChannels.add(c);
	}
	
	@Override
	public void deregisterInputChannel(InputChannel c){
		inputChannels.remove(c);
	}
	
	@Override
	public void addCloseListener(ClosedListener listener)
	{
		closedListeners.add(listener);
	}
	
	@Override
	public void removeCloseListener(ClosedListener listener){
		closedListeners.remove(listener);
	}
	
	@Override
	public void addEstablishedListener(EstablishedListener listener){
		establishedListeners.add(listener);
	}
	
	@Override
	public void removeEstablishedListener(EstablishedListener listener){
		establishedListeners.remove(listener);
	}
	
	/**
	 * {@link ErrorListener} are not supported by this {@link HttpCommunicationConnection}, because every error
	 * is handled via java standard exceptions
	 */
	@Override
	public void addErrorListener(ErrorListener listener){

		throw new UnsupportedOperationException();
		//errorListeners.add(listener);
	}
	
	/**
	 * {@link ErrorListener} are not supported by this {@link HttpCommunicationConnection}, because every error
	 * is handled via java standard exceptions
	 */
	@Override
	public void removeErrorListener(ErrorListener listener){

		throw new UnsupportedOperationException();
		//errorListeners.remove(listener);
	}

	/**
	 * Set the http status code of the response, 200, 404, etc. 
	 * @param httpStatusCode
	 */
	public void setResponseStatusCode(int httpStatusCode)
	{
		response.setStatus(httpStatusCode);
	}

	/**
	 * Get the http status code of the response, 200, 404, etc.
	 * @return
	 */
	public int getResponseStatusCode()
	{
		return response.getStatus();
	}
}
